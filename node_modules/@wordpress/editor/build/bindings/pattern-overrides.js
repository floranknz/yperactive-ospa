"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _i18n = require("@wordpress/i18n");
var _blockEditor = require("@wordpress/block-editor");
/**
 * WordPress dependencies
 */

const CONTENT = 'content';
var _default = exports.default = {
  name: 'core/pattern-overrides',
  label: (0, _i18n._x)('Pattern Overrides', 'block bindings source'),
  getValue({
    registry,
    clientId,
    attributeName
  }) {
    const {
      getBlockAttributes,
      getBlockParentsByBlockName
    } = registry.select(_blockEditor.store);
    const currentBlockAttributes = getBlockAttributes(clientId);
    const [patternClientId] = getBlockParentsByBlockName(clientId, 'core/block', true);
    const overridableValue = getBlockAttributes(patternClientId)?.[CONTENT]?.[currentBlockAttributes?.metadata?.name]?.[attributeName];

    // If there is no pattern client ID, or it is not overwritten, return the default value.
    if (!patternClientId || overridableValue === undefined) {
      return currentBlockAttributes[attributeName];
    }
    return overridableValue === '' ? undefined : overridableValue;
  },
  setValues({
    registry,
    clientId,
    attributes
  }) {
    const {
      getBlockAttributes,
      getBlockParentsByBlockName,
      getBlocks
    } = registry.select(_blockEditor.store);
    const currentBlockAttributes = getBlockAttributes(clientId);
    const blockName = currentBlockAttributes?.metadata?.name;
    if (!blockName) {
      return;
    }
    const [patternClientId] = getBlockParentsByBlockName(clientId, 'core/block', true);

    // If there is no pattern client ID, sync blocks with the same name and same attributes.
    if (!patternClientId) {
      const syncBlocksWithSameName = blocks => {
        for (const block of blocks) {
          if (block.attributes?.metadata?.name === blockName) {
            registry.dispatch(_blockEditor.store).updateBlockAttributes(block.clientId, attributes);
          }
          syncBlocksWithSameName(block.innerBlocks);
        }
      };
      syncBlocksWithSameName(getBlocks());
      return;
    }
    const currentBindingValue = getBlockAttributes(patternClientId)?.[CONTENT];
    registry.dispatch(_blockEditor.store).updateBlockAttributes(patternClientId, {
      [CONTENT]: {
        ...currentBindingValue,
        [blockName]: {
          ...currentBindingValue?.[blockName],
          ...Object.entries(attributes).reduce((acc, [key, value]) => {
            // TODO: We need a way to represent `undefined` in the serialized overrides.
            // Also see: https://github.com/WordPress/gutenberg/pull/57249#discussion_r1452987871
            // We use an empty string to represent undefined for now until
            // we support a richer format for overrides and the block bindings API.
            acc[key] = value === undefined ? '' : value;
            return acc;
          }, {})
        }
      }
    });
  },
  lockAttributesEditing: false
};
//# sourceMappingURL=pattern-overrides.js.map