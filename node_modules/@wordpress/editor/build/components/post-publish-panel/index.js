"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PostPublishPanel = void 0;
var _react = require("react");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _compose = require("@wordpress/compose");
var _icons = require("@wordpress/icons");
var _coreData = require("@wordpress/core-data");
var _postPublishButton = _interopRequireDefault(require("../post-publish-button"));
var _prepublish = _interopRequireDefault(require("./prepublish"));
var _postpublish = _interopRequireDefault(require("./postpublish"));
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

class PostPublishPanel extends _element.Component {
  constructor() {
    super(...arguments);
    this.onSubmit = this.onSubmit.bind(this);
  }
  componentDidUpdate(prevProps) {
    // Automatically collapse the publish sidebar when a post
    // is published and the user makes an edit.
    if (prevProps.isPublished && !this.props.isSaving && this.props.isDirty) {
      this.props.onClose();
    }
  }
  onSubmit() {
    const {
      onClose,
      hasPublishAction,
      isPostTypeViewable
    } = this.props;
    if (!hasPublishAction || !isPostTypeViewable) {
      onClose();
    }
  }
  render() {
    const {
      forceIsDirty,
      isBeingScheduled,
      isPublished,
      isPublishSidebarEnabled,
      isScheduled,
      isSaving,
      isSavingNonPostEntityChanges,
      onClose,
      onTogglePublishSidebar,
      PostPublishExtension,
      PrePublishExtension,
      ...additionalProps
    } = this.props;
    const {
      hasPublishAction,
      isDirty,
      isPostTypeViewable,
      ...propsForPanel
    } = additionalProps;
    const isPublishedOrScheduled = isPublished || isScheduled && isBeingScheduled;
    const isPrePublish = !isPublishedOrScheduled && !isSaving;
    const isPostPublish = isPublishedOrScheduled && !isSaving;
    return (0, _react.createElement)("div", {
      className: "editor-post-publish-panel",
      ...propsForPanel
    }, (0, _react.createElement)("div", {
      className: "editor-post-publish-panel__header"
    }, isPostPublish ? (0, _react.createElement)(_components.Button, {
      onClick: onClose,
      icon: _icons.closeSmall,
      label: (0, _i18n.__)('Close panel')
    }) : (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)("div", {
      className: "editor-post-publish-panel__header-publish-button"
    }, (0, _react.createElement)(_postPublishButton.default, {
      focusOnMount: true,
      onSubmit: this.onSubmit,
      forceIsDirty: forceIsDirty
    })), (0, _react.createElement)("div", {
      className: "editor-post-publish-panel__header-cancel-button"
    }, (0, _react.createElement)(_components.Button, {
      disabled: isSavingNonPostEntityChanges,
      onClick: onClose,
      variant: "secondary"
    }, (0, _i18n.__)('Cancel'))))), (0, _react.createElement)("div", {
      className: "editor-post-publish-panel__content"
    }, isPrePublish && (0, _react.createElement)(_prepublish.default, null, PrePublishExtension && (0, _react.createElement)(PrePublishExtension, null)), isPostPublish && (0, _react.createElement)(_postpublish.default, {
      focusOnMount: true
    }, PostPublishExtension && (0, _react.createElement)(PostPublishExtension, null)), isSaving && (0, _react.createElement)(_components.Spinner, null)), (0, _react.createElement)("div", {
      className: "editor-post-publish-panel__footer"
    }, (0, _react.createElement)(_components.CheckboxControl, {
      __nextHasNoMarginBottom: true,
      label: (0, _i18n.__)('Always show pre-publish checks.'),
      checked: isPublishSidebarEnabled,
      onChange: onTogglePublishSidebar
    })));
  }
}
exports.PostPublishPanel = PostPublishPanel;
var _default = exports.default = (0, _compose.compose)([(0, _data.withSelect)(select => {
  var _getCurrentPost$_link;
  const {
    getPostType
  } = select(_coreData.store);
  const {
    getCurrentPost,
    getEditedPostAttribute,
    isCurrentPostPublished,
    isCurrentPostScheduled,
    isEditedPostBeingScheduled,
    isEditedPostDirty,
    isAutosavingPost,
    isSavingPost,
    isSavingNonPostEntityChanges
  } = select(_store.store);
  const {
    isPublishSidebarEnabled
  } = select(_store.store);
  const postType = getPostType(getEditedPostAttribute('type'));
  return {
    hasPublishAction: (_getCurrentPost$_link = getCurrentPost()._links?.['wp:action-publish']) !== null && _getCurrentPost$_link !== void 0 ? _getCurrentPost$_link : false,
    isPostTypeViewable: postType?.viewable,
    isBeingScheduled: isEditedPostBeingScheduled(),
    isDirty: isEditedPostDirty(),
    isPublished: isCurrentPostPublished(),
    isPublishSidebarEnabled: isPublishSidebarEnabled(),
    isSaving: isSavingPost() && !isAutosavingPost(),
    isSavingNonPostEntityChanges: isSavingNonPostEntityChanges(),
    isScheduled: isCurrentPostScheduled()
  };
}), (0, _data.withDispatch)((dispatch, {
  isPublishSidebarEnabled
}) => {
  const {
    disablePublishSidebar,
    enablePublishSidebar
  } = dispatch(_store.store);
  return {
    onTogglePublishSidebar: () => {
      if (isPublishSidebarEnabled) {
        disablePublishSidebar();
      } else {
        enablePublishSidebar();
      }
    }
  };
}), _components.withFocusReturn, _components.withConstrainedTabbing])(PostPublishPanel);
//# sourceMappingURL=index.js.map