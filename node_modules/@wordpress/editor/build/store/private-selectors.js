"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCurrentTemplateTemplateParts = void 0;
exports.getInserterSidebarToggleRef = getInserterSidebarToggleRef;
exports.getInsertionPoint = void 0;
exports.getListViewToggleRef = getListViewToggleRef;
exports.getPostIcon = void 0;
var _blockEditor = require("@wordpress/block-editor");
var _data = require("@wordpress/data");
var _icons = require("@wordpress/icons");
var _coreData = require("@wordpress/core-data");
var _selectors = require("./selectors");
var _constants = require("./constants");
var _getFilteredTemplateParts = require("./utils/get-filtered-template-parts");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const EMPTY_INSERTION_POINT = {
  rootClientId: undefined,
  insertionIndex: undefined,
  filterValue: undefined
};

/**
 * Get the insertion point for the inserter.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object} The root client ID, index to insert at and starting filter value.
 */
const getInsertionPoint = exports.getInsertionPoint = (0, _data.createRegistrySelector)(select => (0, _data.createSelector)(state => {
  if (typeof state.blockInserterPanel === 'object') {
    return state.blockInserterPanel;
  }
  if ((0, _selectors.getRenderingMode)(state) === 'template-locked') {
    const [postContentClientId] = select(_blockEditor.store).getBlocksByName('core/post-content');
    if (postContentClientId) {
      return {
        rootClientId: postContentClientId,
        insertionIndex: undefined,
        filterValue: undefined
      };
    }
  }
  return EMPTY_INSERTION_POINT;
}, state => {
  const [postContentClientId] = select(_blockEditor.store).getBlocksByName('core/post-content');
  return [state.blockInserterPanel, (0, _selectors.getRenderingMode)(state), postContentClientId];
}));
function getListViewToggleRef(state) {
  return state.listViewToggleRef;
}
function getInserterSidebarToggleRef(state) {
  return state.inserterSidebarToggleRef;
}
const CARD_ICONS = {
  wp_block: _icons.symbol,
  wp_navigation: _icons.navigation,
  page: _icons.page,
  post: _icons.verse
};
const getPostIcon = exports.getPostIcon = (0, _data.createRegistrySelector)(select => (state, postType, options) => {
  {
    if (postType === 'wp_template_part' || postType === 'wp_template') {
      return (0, _selectors.__experimentalGetDefaultTemplatePartAreas)(state).find(item => options.area === item.area)?.icon || _icons.layout;
    }
    if (CARD_ICONS[postType]) {
      return CARD_ICONS[postType];
    }
    const postTypeEntity = select(_coreData.store).getPostType(postType);
    // `icon` is the `menu_icon` property of a post type. We
    // only handle `dashicons` for now, even if the `menu_icon`
    // also supports urls and svg as values.
    if (postTypeEntity?.icon?.startsWith('dashicons-')) {
      return postTypeEntity.icon.slice(10);
    }
    return _icons.page;
  }
});

/**
 * Returns the template parts and their blocks for the current edited template.
 *
 * @param {Object} state Global application state.
 * @return {Array} Template parts and their blocks in an array.
 */
const getCurrentTemplateTemplateParts = exports.getCurrentTemplateTemplateParts = (0, _data.createRegistrySelector)(select => () => {
  const templateParts = select(_coreData.store).getEntityRecords('postType', _constants.TEMPLATE_PART_POST_TYPE, {
    per_page: -1
  });
  const clientIds = select(_blockEditor.store).getBlocksByName('core/template-part');
  const blocks = select(_blockEditor.store).getBlocksByClientId(clientIds);
  return (0, _getFilteredTemplateParts.getFilteredTemplatePartBlocks)(blocks, templateParts);
});
//# sourceMappingURL=private-selectors.js.map