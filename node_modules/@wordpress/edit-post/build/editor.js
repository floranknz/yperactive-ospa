"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _data = require("@wordpress/data");
var _editor = require("@wordpress/editor");
var _element = require("@wordpress/element");
var _components = require("@wordpress/components");
var _coreData = require("@wordpress/core-data");
var _commands = require("@wordpress/commands");
var _layout = _interopRequireDefault(require("./components/layout"));
var _editorInitialization = _interopRequireDefault(require("./components/editor-initialization"));
var _store = require("./store");
var _lockUnlock = require("./lock-unlock");
var _useNavigateToEntityRecord = _interopRequireDefault(require("./hooks/use-navigate-to-entity-record"));
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  ExperimentalEditorProvider
} = (0, _lockUnlock.unlock)(_editor.privateApis);
function Editor({
  postId: initialPostId,
  postType: initialPostType,
  settings,
  initialEdits,
  ...props
}) {
  const {
    currentPost,
    onNavigateToEntityRecord,
    onNavigateToPreviousEntityRecord
  } = (0, _useNavigateToEntityRecord.default)(initialPostId, initialPostType, 'post-only');
  const {
    post,
    template
  } = (0, _data.useSelect)(select => {
    var _getPostType$viewable;
    const {
      getEditedPostTemplate
    } = select(_store.store);
    const {
      getEntityRecord,
      getPostType,
      canUser
    } = select(_coreData.store);
    const {
      getEditorSettings
    } = select(_editor.store);
    const postObject = getEntityRecord('postType', currentPost.postType, currentPost.postId);
    const supportsTemplateMode = getEditorSettings().supportsTemplateMode;
    const isViewable = (_getPostType$viewable = getPostType(currentPost.postType)?.viewable) !== null && _getPostType$viewable !== void 0 ? _getPostType$viewable : false;
    const canViewTemplate = canUser('read', 'templates');
    return {
      template: supportsTemplateMode && isViewable && canViewTemplate && currentPost.postType !== 'wp_template' ? getEditedPostTemplate() : null,
      post: postObject
    };
  }, [currentPost.postType, currentPost.postId]);
  const editorSettings = (0, _element.useMemo)(() => ({
    ...settings,
    onNavigateToEntityRecord,
    onNavigateToPreviousEntityRecord,
    defaultRenderingMode: 'post-only'
  }), [settings, onNavigateToEntityRecord, onNavigateToPreviousEntityRecord]);
  const initialPost = (0, _element.useMemo)(() => {
    return {
      type: initialPostType,
      id: initialPostId
    };
  }, [initialPostType, initialPostId]);
  if (!post) {
    return null;
  }
  return (0, _react.createElement)(_components.SlotFillProvider, null, (0, _react.createElement)(ExperimentalEditorProvider, {
    settings: editorSettings,
    post: post,
    initialEdits: initialEdits,
    useSubRegistry: false,
    __unstableTemplate: template,
    ...props
  }, (0, _react.createElement)(_editor.ErrorBoundary, null, (0, _react.createElement)(_commands.CommandMenu, null), (0, _react.createElement)(_editorInitialization.default, null), (0, _react.createElement)(_layout.default, {
    initialPost: initialPost
  })), (0, _react.createElement)(_editor.PostLockedModal, null)));
}
var _default = exports.default = Editor;
//# sourceMappingURL=editor.js.map