import { createElement } from "react";
/**
 * WordPress dependencies
 */
import { Modal, Button, TextControl, __experimentalHStack as HStack, __experimentalVStack as VStack, ToggleControl } from '@wordpress/components';
import { __, _x } from '@wordpress/i18n';
import { useState } from '@wordpress/element';
import { useDispatch } from '@wordpress/data';
import { store as noticesStore } from '@wordpress/notices';

/**
 * Internal dependencies
 */
import { PATTERN_DEFAULT_CATEGORY, PATTERN_SYNC_TYPES } from '../constants';
import { store as patternsStore } from '../store';
import CategorySelector from './category-selector';
import { useAddPatternCategory } from '../private-hooks';
import { unlock } from '../lock-unlock';
export default function CreatePatternModal({
  className = 'patterns-menu-items__convert-modal',
  modalTitle = __('Create pattern'),
  ...restProps
}) {
  return createElement(Modal, {
    title: modalTitle,
    onRequestClose: restProps.onClose,
    overlayClassName: className
  }, createElement(CreatePatternModalContents, {
    ...restProps
  }));
}
export function CreatePatternModalContents({
  confirmLabel = __('Create'),
  defaultCategories = [],
  content,
  onClose,
  onError,
  onSuccess,
  defaultSyncType = PATTERN_SYNC_TYPES.full,
  defaultTitle = ''
}) {
  const [syncType, setSyncType] = useState(defaultSyncType);
  const [categoryTerms, setCategoryTerms] = useState(defaultCategories);
  const [title, setTitle] = useState(defaultTitle);
  const [isSaving, setIsSaving] = useState(false);
  const {
    createPattern
  } = unlock(useDispatch(patternsStore));
  const {
    createErrorNotice
  } = useDispatch(noticesStore);
  const {
    categoryMap,
    findOrCreateTerm
  } = useAddPatternCategory();
  async function onCreate(patternTitle, sync) {
    if (!title || isSaving) {
      return;
    }
    try {
      setIsSaving(true);
      const categories = await Promise.all(categoryTerms.map(termName => findOrCreateTerm(termName)));
      const newPattern = await createPattern(patternTitle, sync, typeof content === 'function' ? content() : content, categories);
      onSuccess({
        pattern: newPattern,
        categoryId: PATTERN_DEFAULT_CATEGORY
      });
    } catch (error) {
      createErrorNotice(error.message, {
        type: 'snackbar',
        id: 'pattern-create'
      });
      onError?.();
    } finally {
      setIsSaving(false);
      setCategoryTerms([]);
      setTitle('');
    }
  }
  return createElement("form", {
    onSubmit: event => {
      event.preventDefault();
      onCreate(title, syncType);
    }
  }, createElement(VStack, {
    spacing: "5"
  }, createElement(TextControl, {
    label: __('Name'),
    value: title,
    onChange: setTitle,
    placeholder: __('My pattern'),
    className: "patterns-create-modal__name-input",
    __nextHasNoMarginBottom: true,
    __next40pxDefaultSize: true
  }), createElement(CategorySelector, {
    categoryTerms: categoryTerms,
    onChange: setCategoryTerms,
    categoryMap: categoryMap
  }), createElement(ToggleControl, {
    label: _x('Synced', 'Option that makes an individual pattern synchronized'),
    help: __('Sync this pattern across multiple locations.'),
    checked: syncType === PATTERN_SYNC_TYPES.full,
    onChange: () => {
      setSyncType(syncType === PATTERN_SYNC_TYPES.full ? PATTERN_SYNC_TYPES.unsynced : PATTERN_SYNC_TYPES.full);
    }
  }), createElement(HStack, {
    justify: "right"
  }, createElement(Button, {
    __next40pxDefaultSize: true,
    variant: "tertiary",
    onClick: () => {
      onClose();
      setTitle('');
    }
  }, __('Cancel')), createElement(Button, {
    __next40pxDefaultSize: true,
    variant: "primary",
    type: "submit",
    "aria-disabled": !title || isSaving,
    isBusy: isSaving
  }, confirmLabel))));
}
//# sourceMappingURL=create-pattern-modal.js.map