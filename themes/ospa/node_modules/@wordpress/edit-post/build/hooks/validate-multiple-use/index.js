"use strict";

var _react = require("react");
var _blocks = require("@wordpress/blocks");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _blockEditor = require("@wordpress/block-editor");
var _hooks = require("@wordpress/hooks");
var _i18n = require("@wordpress/i18n");
var _compose = require("@wordpress/compose");
/**
 * WordPress dependencies
 */

/**
 * Recursively find very first block of an specific block type.
 *
 * @param {Object[]} blocks List of blocks.
 * @param {string}   name   Block name to search.
 *
 * @return {Object|undefined} Return block object or undefined.
 */
function findFirstOfSameType(blocks, name) {
  if (!Array.isArray(blocks) || !blocks.length) {
    return;
  }
  for (const block of blocks) {
    if (block.name === name) {
      return block;
    }

    // Search inside innerBlocks.
    const firstBlock = findFirstOfSameType(block.innerBlocks, name);
    if (firstBlock) {
      return firstBlock;
    }
  }
}
const enhance = (0, _compose.compose)(
/**
 * For blocks whose block type doesn't support `multiple`, provides the
 * wrapped component with `originalBlockClientId` -- a reference to the
 * first block of the same type in the content -- if and only if that
 * "original" block is not the current one. Thus, an inexisting
 * `originalBlockClientId` prop signals that the block is valid.
 *
 * @param {Component} WrappedBlockEdit A filtered BlockEdit instance.
 *
 * @return {Component} Enhanced component with merged state data props.
 */
(0, _data.withSelect)((select, block) => {
  const multiple = (0, _blocks.hasBlockSupport)(block.name, 'multiple', true);

  // For block types with `multiple` support, there is no "original
  // block" to be found in the content, as the block itself is valid.
  if (multiple) {
    return {};
  }

  // Otherwise, only pass `originalBlockClientId` if it refers to a different
  // block from the current one.
  const blocks = select(_blockEditor.store).getBlocks();
  const firstOfSameType = findFirstOfSameType(blocks, block.name);
  const isInvalid = firstOfSameType && firstOfSameType.clientId !== block.clientId;
  return {
    originalBlockClientId: isInvalid && firstOfSameType.clientId
  };
}), (0, _data.withDispatch)((dispatch, {
  originalBlockClientId
}) => ({
  selectFirst: () => dispatch(_blockEditor.store).selectBlock(originalBlockClientId)
})));
const withMultipleValidation = (0, _compose.createHigherOrderComponent)(BlockEdit => {
  return enhance(({
    originalBlockClientId,
    selectFirst,
    ...props
  }) => {
    if (!originalBlockClientId) {
      return (0, _react.createElement)(BlockEdit, {
        ...props
      });
    }
    const blockType = (0, _blocks.getBlockType)(props.name);
    const outboundType = getOutboundType(props.name);
    return [(0, _react.createElement)("div", {
      key: "invalid-preview",
      style: {
        minHeight: '60px'
      }
    }, (0, _react.createElement)(BlockEdit, {
      key: "block-edit",
      ...props
    })), (0, _react.createElement)(_blockEditor.Warning, {
      key: "multiple-use-warning",
      actions: [(0, _react.createElement)(_components.Button, {
        key: "find-original",
        variant: "secondary",
        onClick: selectFirst
      }, (0, _i18n.__)('Find original')), (0, _react.createElement)(_components.Button, {
        key: "remove",
        variant: "secondary",
        onClick: () => props.onReplace([])
      }, (0, _i18n.__)('Remove')), outboundType && (0, _react.createElement)(_components.Button, {
        key: "transform",
        variant: "secondary",
        onClick: () => props.onReplace((0, _blocks.createBlock)(outboundType.name, props.attributes))
      }, (0, _i18n.__)('Transform into:'), " ", outboundType.title)]
    }, (0, _react.createElement)("strong", null, blockType?.title, ": "), (0, _i18n.__)('This block can only be used once.'))];
  });
}, 'withMultipleValidation');

/**
 * Given a base block name, returns the default block type to which to offer
 * transforms.
 *
 * @param {string} blockName Base block name.
 *
 * @return {?Object} The chosen default block type.
 */
function getOutboundType(blockName) {
  // Grab the first outbound transform.
  const transform = (0, _blocks.findTransform)((0, _blocks.getBlockTransforms)('to', blockName), ({
    type,
    blocks
  }) => type === 'block' && blocks.length === 1 // What about when .length > 1?
  );
  if (!transform) {
    return null;
  }
  return (0, _blocks.getBlockType)(transform.blocks[0]);
}
(0, _hooks.addFilter)('editor.BlockEdit', 'core/edit-post/validate-multiple-use/with-multiple-validation', withMultipleValidation);
//# sourceMappingURL=index.js.map