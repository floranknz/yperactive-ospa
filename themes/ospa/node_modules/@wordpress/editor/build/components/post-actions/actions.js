"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePostActions = usePostActions;
var _react = require("react");
var _icons = require("@wordpress/icons");
var _url = require("@wordpress/url");
var _data = require("@wordpress/data");
var _htmlEntities = require("@wordpress/html-entities");
var _coreData = require("@wordpress/core-data");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _element = require("@wordpress/element");
var _components = require("@wordpress/components");
var _constants = require("../../store/constants");
var _store = require("../../store");
var _lockUnlock = require("../../lock-unlock");
var _isTemplateRevertable = _interopRequireDefault(require("../../store/utils/is-template-revertable"));
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function getItemTitle(item) {
  if (typeof item.title === 'string') {
    return (0, _htmlEntities.decodeEntities)(item.title);
  }
  return (0, _htmlEntities.decodeEntities)(item.title?.rendered || '');
}
const trashPostAction = {
  id: 'move-to-trash',
  label: (0, _i18n.__)('Move to Trash'),
  isPrimary: true,
  icon: _icons.trash,
  isEligible({
    status
  }) {
    return status !== 'trash';
  },
  supportsBulk: true,
  hideModalHeader: true,
  RenderModal: ({
    items: posts,
    closeModal,
    onActionStart,
    onActionPerformed
  }) => {
    const [isBusy, setIsBusy] = (0, _element.useState)(false);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    const {
      deleteEntityRecord
    } = (0, _data.useDispatch)(_coreData.store);
    return (0, _react.createElement)(_components.__experimentalVStack, {
      spacing: "5"
    }, (0, _react.createElement)(_components.__experimentalText, null, posts.length === 1 ? (0, _i18n.sprintf)(
    // translators: %s: The page's title.
    (0, _i18n.__)('Are you sure you want to delete "%s"?'), getItemTitle(posts[0])) : (0, _i18n.sprintf)(
    // translators: %d: The number of pages (2 or more).
    (0, _i18n._n)('Are you sure you want to delete %d page?', 'Are you sure you want to delete %d pages?', posts.length), posts.length)), (0, _react.createElement)(_components.__experimentalHStack, {
      justify: "right"
    }, (0, _react.createElement)(_components.Button, {
      variant: "tertiary",
      onClick: closeModal,
      disabled: isBusy,
      __experimentalIsFocusable: true
    }, (0, _i18n.__)('Cancel')), (0, _react.createElement)(_components.Button, {
      variant: "primary",
      onClick: async () => {
        setIsBusy(true);
        if (onActionStart) {
          onActionStart(posts);
        }
        const promiseResult = await Promise.allSettled(posts.map(post => {
          return deleteEntityRecord('postType', post.type, post.id, {}, {
            throwOnError: true
          });
        }));
        // If all the promises were fulfilled with success.
        if (promiseResult.every(({
          status
        }) => status === 'fulfilled')) {
          let successMessage;
          if (promiseResult.length === 1) {
            successMessage = (0, _i18n.sprintf)( /* translators: The posts's title. */
            (0, _i18n.__)('"%s" moved to the Trash.'), getItemTitle(posts[0]));
          } else if (posts[0].type === 'page') {
            successMessage = (0, _i18n.sprintf)( /* translators: The number of pages. */
            (0, _i18n.__)('%s pages moved to the Trash.'), posts.length);
          } else {
            successMessage = (0, _i18n.sprintf)( /* translators: The number of posts. */
            (0, _i18n.__)('%s posts moved to the Trash.'), posts.length);
          }
          createSuccessNotice(successMessage, {
            type: 'snackbar',
            id: 'trash-post-action'
          });
        } else {
          // If there was at lease one failure.
          let errorMessage;
          // If we were trying to move a single post to the trash.
          if (promiseResult.length === 1) {
            if (promiseResult[0].reason?.message) {
              errorMessage = promiseResult[0].reason.message;
            } else {
              errorMessage = (0, _i18n.__)('An error occurred while moving the post to the trash.');
            }
            // If we were trying to move multiple posts to the trash
          } else {
            const errorMessages = new Set();
            const failedPromises = promiseResult.filter(({
              status
            }) => status === 'rejected');
            for (const failedPromise of failedPromises) {
              if (failedPromise.reason?.message) {
                errorMessages.add(failedPromise.reason.message);
              }
            }
            if (errorMessages.size === 0) {
              errorMessage = (0, _i18n.__)('An error occurred while moving the posts to the trash.');
            } else if (errorMessages.size === 1) {
              errorMessage = (0, _i18n.sprintf)( /* translators: %s: an error message */
              (0, _i18n.__)('An error occurred while moving the posts to the trash: %s'), [...errorMessages][0]);
            } else {
              errorMessage = (0, _i18n.sprintf)( /* translators: %s: a list of comma separated error messages */
              (0, _i18n.__)('Some errors occurred while moving the pages to the trash: %s'), [...errorMessages].join(','));
            }
          }
          createErrorNotice(errorMessage, {
            type: 'snackbar'
          });
        }
        if (onActionPerformed) {
          onActionPerformed(posts);
        }
        setIsBusy(false);
        closeModal();
      },
      isBusy: isBusy,
      disabled: isBusy,
      __experimentalIsFocusable: true
    }, (0, _i18n.__)('Delete'))));
  }
};
function usePermanentlyDeletePostAction() {
  const {
    createSuccessNotice,
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const {
    deleteEntityRecord
  } = (0, _data.useDispatch)(_coreData.store);
  return (0, _element.useMemo)(() => ({
    id: 'permanently-delete',
    label: (0, _i18n.__)('Permanently delete'),
    supportsBulk: true,
    isEligible({
      status
    }) {
      return status === 'trash';
    },
    async callback(posts, onActionPerformed) {
      const promiseResult = await Promise.allSettled(posts.map(post => {
        return deleteEntityRecord('postType', post.type, post.id, {
          force: true
        }, {
          throwOnError: true
        });
      }));
      // If all the promises were fulfilled with success.
      if (promiseResult.every(({
        status
      }) => status === 'fulfilled')) {
        let successMessage;
        if (promiseResult.length === 1) {
          successMessage = (0, _i18n.sprintf)( /* translators: The posts's title. */
          (0, _i18n.__)('"%s" permanently deleted.'), getItemTitle(posts[0]));
        } else {
          successMessage = (0, _i18n.__)('The posts were permanently deleted.');
        }
        createSuccessNotice(successMessage, {
          type: 'snackbar',
          id: 'permanently-delete-post-action'
        });
        if (onActionPerformed) {
          onActionPerformed(posts);
        }
      } else {
        // If there was at lease one failure.
        let errorMessage;
        // If we were trying to permanently delete a single post.
        if (promiseResult.length === 1) {
          if (promiseResult[0].reason?.message) {
            errorMessage = promiseResult[0].reason.message;
          } else {
            errorMessage = (0, _i18n.__)('An error occurred while permanently deleting the post.');
          }
          // If we were trying to permanently delete multiple posts
        } else {
          const errorMessages = new Set();
          const failedPromises = promiseResult.filter(({
            status
          }) => status === 'rejected');
          for (const failedPromise of failedPromises) {
            if (failedPromise.reason?.message) {
              errorMessages.add(failedPromise.reason.message);
            }
          }
          if (errorMessages.size === 0) {
            errorMessage = (0, _i18n.__)('An error occurred while permanently deleting the posts.');
          } else if (errorMessages.size === 1) {
            errorMessage = (0, _i18n.sprintf)( /* translators: %s: an error message */
            (0, _i18n.__)('An error occurred while permanently deleting the posts: %s'), [...errorMessages][0]);
          } else {
            errorMessage = (0, _i18n.sprintf)( /* translators: %s: a list of comma separated error messages */
            (0, _i18n.__)('Some errors occurred while permanently deleting the posts: %s'), [...errorMessages].join(','));
          }
        }
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    }
  }), [createSuccessNotice, createErrorNotice, deleteEntityRecord]);
}
function useRestorePostAction() {
  const {
    createSuccessNotice,
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const {
    editEntityRecord,
    saveEditedEntityRecord
  } = (0, _data.useDispatch)(_coreData.store);
  return (0, _element.useMemo)(() => ({
    id: 'restore',
    label: (0, _i18n.__)('Restore'),
    isPrimary: true,
    icon: _icons.backup,
    supportsBulk: true,
    isEligible({
      status
    }) {
      return status === 'trash';
    },
    async callback(posts, onActionPerformed) {
      await Promise.allSettled(posts.map(post => {
        return editEntityRecord('postType', post.type, post.id, {
          status: 'draft'
        });
      }));
      const promiseResult = await Promise.allSettled(posts.map(post => {
        return saveEditedEntityRecord('postType', post.type, post.id, {
          throwOnError: true
        });
      }));
      if (promiseResult.every(({
        status
      }) => status === 'fulfilled')) {
        let successMessage;
        if (posts.length === 1) {
          successMessage = (0, _i18n.sprintf)( /* translators: The number of posts. */
          (0, _i18n.__)('"%s" has been restored.'), getItemTitle(posts[0]));
        } else if (posts[0].type === 'page') {
          successMessage = (0, _i18n.sprintf)( /* translators: The number of posts. */
          (0, _i18n.__)('%d pages have been restored.'), posts.length);
        } else {
          successMessage = (0, _i18n.sprintf)( /* translators: The number of posts. */
          (0, _i18n.__)('%d posts have been restored.'), posts.length);
        }
        createSuccessNotice(successMessage, {
          type: 'snackbar',
          id: 'restore-post-action'
        });
        if (onActionPerformed) {
          onActionPerformed(posts);
        }
      } else {
        // If there was at lease one failure.
        let errorMessage;
        // If we were trying to move a single post to the trash.
        if (promiseResult.length === 1) {
          if (promiseResult[0].reason?.message) {
            errorMessage = promiseResult[0].reason.message;
          } else {
            errorMessage = (0, _i18n.__)('An error occurred while restoring the post.');
          }
          // If we were trying to move multiple posts to the trash
        } else {
          const errorMessages = new Set();
          const failedPromises = promiseResult.filter(({
            status
          }) => status === 'rejected');
          for (const failedPromise of failedPromises) {
            if (failedPromise.reason?.message) {
              errorMessages.add(failedPromise.reason.message);
            }
          }
          if (errorMessages.size === 0) {
            errorMessage = (0, _i18n.__)('An error occurred while restoring the posts.');
          } else if (errorMessages.size === 1) {
            errorMessage = (0, _i18n.sprintf)( /* translators: %s: an error message */
            (0, _i18n.__)('An error occurred while restoring the posts: %s'), [...errorMessages][0]);
          } else {
            errorMessage = (0, _i18n.sprintf)( /* translators: %s: a list of comma separated error messages */
            (0, _i18n.__)('Some errors occurred while restoring the posts: %s'), [...errorMessages].join(','));
          }
        }
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    }
  }), [createSuccessNotice, createErrorNotice, editEntityRecord, saveEditedEntityRecord]);
}
const viewPostAction = {
  id: 'view-post',
  label: (0, _i18n.__)('View'),
  isPrimary: true,
  icon: _icons.external,
  isEligible(post) {
    return post.status !== 'trash';
  },
  callback(posts, onActionPerformed) {
    const post = posts[0];
    window.open(post.link, '_blank');
    if (onActionPerformed) {
      onActionPerformed(posts);
    }
  }
};
const postRevisionsAction = {
  id: 'view-post-revisions',
  label: (0, _i18n.__)('View revisions'),
  isPrimary: false,
  isEligible: post => {
    var _post$_links$predeces, _post$_links$version;
    if (post.status === 'trash') {
      return false;
    }
    const lastRevisionId = (_post$_links$predeces = post?._links?.['predecessor-version']?.[0]?.id) !== null && _post$_links$predeces !== void 0 ? _post$_links$predeces : null;
    const revisionsCount = (_post$_links$version = post?._links?.['version-history']?.[0]?.count) !== null && _post$_links$version !== void 0 ? _post$_links$version : 0;
    return lastRevisionId && revisionsCount > 1;
  },
  callback(posts, onActionPerformed) {
    const post = posts[0];
    const href = (0, _url.addQueryArgs)('revision.php', {
      revision: post?._links?.['predecessor-version']?.[0]?.id
    });
    document.location.href = href;
    if (onActionPerformed) {
      onActionPerformed(posts);
    }
  }
};
const renamePostAction = {
  id: 'rename-post',
  label: (0, _i18n.__)('Rename'),
  isEligible(post) {
    return post.status !== 'trash';
  },
  RenderModal: ({
    items,
    closeModal,
    onActionPerformed
  }) => {
    const [item] = items;
    const originalTitle = (0, _htmlEntities.decodeEntities)(typeof item.title === 'string' ? item.title : item.title.rendered);
    const [title, setTitle] = (0, _element.useState)(() => originalTitle);
    const {
      editEntityRecord,
      saveEditedEntityRecord
    } = (0, _data.useDispatch)(_coreData.store);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    async function onRename(event) {
      event.preventDefault();
      try {
        await editEntityRecord('postType', item.type, item.id, {
          title
        });
        // Update state before saving rerenders the list.
        setTitle('');
        closeModal();
        // Persist edited entity.
        await saveEditedEntityRecord('postType', item.type, item.id, {
          throwOnError: true
        });
        createSuccessNotice((0, _i18n.__)('Name updated'), {
          type: 'snackbar'
        });
        onActionPerformed?.(items);
      } catch (error) {
        const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : (0, _i18n.__)('An error occurred while updating the name');
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    }
    return (0, _react.createElement)("form", {
      onSubmit: onRename
    }, (0, _react.createElement)(_components.__experimentalVStack, {
      spacing: "5"
    }, (0, _react.createElement)(_components.TextControl, {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      label: (0, _i18n.__)('Name'),
      value: title,
      onChange: setTitle,
      required: true
    }), (0, _react.createElement)(_components.__experimentalHStack, {
      justify: "right"
    }, (0, _react.createElement)(_components.Button, {
      __next40pxDefaultSize: true,
      variant: "tertiary",
      onClick: () => {
        closeModal();
      }
    }, (0, _i18n.__)('Cancel')), (0, _react.createElement)(_components.Button, {
      __next40pxDefaultSize: true,
      variant: "primary",
      type: "submit"
    }, (0, _i18n.__)('Save')))));
  }
};
const duplicatePostAction = {
  id: 'duplicate-post',
  label: (0, _i18n._x)('Duplicate', 'action label'),
  isEligible({
    status
  }) {
    return status !== 'trash';
  },
  RenderModal: ({
    items,
    closeModal,
    onActionPerformed
  }) => {
    const [item] = items;
    const [isCreatingPage, setIsCreatingPage] = (0, _element.useState)(false);
    const [title, setTitle] = (0, _element.useState)((0, _i18n.sprintf)( /* translators: %s: Existing item title */
    (0, _i18n.__)('%s (Copy)'), getItemTitle(item)));
    const {
      saveEntityRecord
    } = (0, _data.useDispatch)(_coreData.store);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    async function createPage(event) {
      event.preventDefault();
      if (isCreatingPage) {
        return;
      }
      setIsCreatingPage(true);
      try {
        const newItem = await saveEntityRecord('postType', item.type, {
          status: 'draft',
          title,
          slug: title || (0, _i18n.__)('No title'),
          author: item.author,
          comment_status: item.comment_status,
          content: typeof item.content === 'string' ? item.content : item.content.raw,
          excerpt: item.excerpt.raw,
          meta: item.meta,
          parent: item.parent,
          password: item.password,
          template: item.template,
          format: item.format,
          featured_media: item.featured_media,
          menu_order: item.menu_order,
          ping_status: item.ping_status,
          categories: item.categories,
          tags: item.tags
        }, {
          throwOnError: true
        });
        createSuccessNotice((0, _i18n.sprintf)(
        // translators: %s: Title of the created template e.g: "Category".
        (0, _i18n.__)('"%s" successfully created.'), newItem.title?.rendered || title), {
          id: 'duplicate-post-action',
          type: 'snackbar'
        });
        if (onActionPerformed) {
          onActionPerformed([newItem]);
        }
      } catch (error) {
        const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : (0, _i18n.__)('An error occurred while duplicating the page.');
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      } finally {
        setIsCreatingPage(false);
        closeModal();
      }
    }
    return (0, _react.createElement)("form", {
      onSubmit: createPage
    }, (0, _react.createElement)(_components.__experimentalVStack, {
      spacing: 3
    }, (0, _react.createElement)(_components.TextControl, {
      label: (0, _i18n.__)('Title'),
      onChange: setTitle,
      placeholder: (0, _i18n.__)('No title'),
      value: title
    }), (0, _react.createElement)(_components.__experimentalHStack, {
      spacing: 2,
      justify: "end"
    }, (0, _react.createElement)(_components.Button, {
      variant: "tertiary",
      onClick: closeModal
    }, (0, _i18n.__)('Cancel')), (0, _react.createElement)(_components.Button, {
      variant: "primary",
      type: "submit",
      isBusy: isCreatingPage,
      "aria-disabled": isCreatingPage
    }, (0, _i18n._x)('Duplicate', 'action label')))));
  }
};
const resetTemplateAction = {
  id: 'reset-template',
  label: (0, _i18n.__)('Reset'),
  isEligible: _isTemplateRevertable.default,
  icon: _icons.backup,
  supportsBulk: true,
  hideModalHeader: true,
  RenderModal: ({
    items,
    closeModal,
    onActionStart,
    onActionPerformed
  }) => {
    const [isBusy, setIsBusy] = (0, _element.useState)(false);
    const {
      revertTemplate
    } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
    const {
      saveEditedEntityRecord
    } = (0, _data.useDispatch)(_coreData.store);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    const onConfirm = async () => {
      try {
        for (const template of items) {
          await revertTemplate(template, {
            allowUndo: false
          });
          await saveEditedEntityRecord('postType', template.type, template.id);
        }
        createSuccessNotice(items.length > 1 ? (0, _i18n.sprintf)( /* translators: The number of items. */
        (0, _i18n.__)('%s items reset.'), items.length) : (0, _i18n.sprintf)( /* translators: The template/part's name. */
        (0, _i18n.__)('"%s" reset.'), (0, _htmlEntities.decodeEntities)(items[0].title.rendered)), {
          type: 'snackbar',
          id: 'revert-template-action'
        });
      } catch (error) {
        let fallbackErrorMessage;
        if (items[0].type === _constants.TEMPLATE_POST_TYPE) {
          fallbackErrorMessage = items.length === 1 ? (0, _i18n.__)('An error occurred while reverting the template.') : (0, _i18n.__)('An error occurred while reverting the templates.');
        } else {
          fallbackErrorMessage = items.length === 1 ? (0, _i18n.__)('An error occurred while reverting the template part.') : (0, _i18n.__)('An error occurred while reverting the template parts.');
        }
        const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : fallbackErrorMessage;
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    };
    return (0, _react.createElement)(_components.__experimentalVStack, {
      spacing: "5"
    }, (0, _react.createElement)(_components.__experimentalText, null, (0, _i18n.__)('Reset to default and clear all customizations?')), (0, _react.createElement)(_components.__experimentalHStack, {
      justify: "right"
    }, (0, _react.createElement)(_components.Button, {
      variant: "tertiary",
      onClick: closeModal,
      disabled: isBusy,
      __experimentalIsFocusable: true
    }, (0, _i18n.__)('Cancel')), (0, _react.createElement)(_components.Button, {
      variant: "primary",
      onClick: async () => {
        setIsBusy(true);
        if (onActionStart) {
          onActionStart(items);
        }
        await onConfirm(items);
        onActionPerformed?.(items);
        closeModal();
        isBusy(false);
      },
      isBusy: isBusy,
      disabled: isBusy,
      __experimentalIsFocusable: true
    }, (0, _i18n.__)('Reset'))));
  }
};

/**
 * Check if a template is removable.
 * Copy from packages/edit-site/src/utils/is-template-removable.js.
 *
 * @param {Object} template The template entity to check.
 * @return {boolean} Whether the template is revertable.
 */
function isTemplateRemovable(template) {
  if (!template) {
    return false;
  }
  return template.source === _constants.TEMPLATE_ORIGINS.custom && !template.has_theme_file;
}
const deleteTemplateAction = {
  id: 'delete-template',
  label: (0, _i18n.__)('Delete'),
  isEligible: isTemplateRemovable,
  icon: _icons.trash,
  supportsBulk: true,
  hideModalHeader: true,
  RenderModal: ({
    items: templates,
    closeModal,
    onActionStart,
    onActionPerformed
  }) => {
    const [isBusy, setIsBusy] = (0, _element.useState)(false);
    const {
      removeTemplates
    } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
    return (0, _react.createElement)(_components.__experimentalVStack, {
      spacing: "5"
    }, (0, _react.createElement)(_components.__experimentalText, null, templates.length > 1 ? (0, _i18n.sprintf)(
    // translators: %d: number of items to delete.
    (0, _i18n._n)('Delete %d item?', 'Delete %d items?', templates.length), templates.length) : (0, _i18n.sprintf)(
    // translators: %s: The template or template part's titles
    (0, _i18n.__)('Delete "%s"?'), (0, _htmlEntities.decodeEntities)(templates?.[0]?.title?.rendered))), (0, _react.createElement)(_components.__experimentalHStack, {
      justify: "right"
    }, (0, _react.createElement)(_components.Button, {
      variant: "tertiary",
      onClick: closeModal,
      disabled: isBusy,
      __experimentalIsFocusable: true
    }, (0, _i18n.__)('Cancel')), (0, _react.createElement)(_components.Button, {
      variant: "primary",
      onClick: async () => {
        setIsBusy(true);
        if (onActionStart) {
          onActionStart(templates);
        }
        await removeTemplates(templates, {
          allowUndo: false
        });
        onActionPerformed?.(templates);
        setIsBusy(false);
        closeModal();
      },
      isBusy: isBusy,
      disabled: isBusy,
      __experimentalIsFocusable: true
    }, (0, _i18n.__)('Delete'))));
  }
};
const renameTemplateAction = {
  id: 'rename-template',
  label: (0, _i18n.__)('Rename'),
  isEligible: template => {
    // We can only remove templates or template parts that can be removed.
    // Additionally in the case of templates, we can only remove custom templates.
    if (!isTemplateRemovable(template) || template.type === _constants.TEMPLATE_POST_TYPE && !template.is_custom) {
      return false;
    }
    return true;
  },
  RenderModal: ({
    items: templates,
    closeModal,
    onActionPerformed
  }) => {
    const template = templates[0];
    const title = (0, _htmlEntities.decodeEntities)(template.title.rendered);
    const [editedTitle, setEditedTitle] = (0, _element.useState)(title);
    const {
      editEntityRecord,
      __experimentalSaveSpecifiedEntityEdits: saveSpecifiedEntityEdits
    } = (0, _data.useDispatch)(_coreData.store);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    async function onTemplateRename(event) {
      event.preventDefault();
      try {
        await editEntityRecord('postType', template.type, template.id, {
          title: editedTitle
        });
        // Update state before saving rerenders the list.
        setEditedTitle('');
        closeModal();
        // Persist edited entity.
        await saveSpecifiedEntityEdits('postType', template.type, template.id, ['title'],
        // Only save title to avoid persisting other edits.
        {
          throwOnError: true
        });
        createSuccessNotice(template.type === _constants.TEMPLATE_POST_TYPE ? (0, _i18n.__)('Template renamed.') : (0, _i18n.__)('Template part renamed.'), {
          type: 'snackbar'
        });
        onActionPerformed?.(templates);
      } catch (error) {
        const fallbackErrorMessage = template.type === _constants.TEMPLATE_POST_TYPE ? (0, _i18n.__)('An error occurred while renaming the template.') : (0, _i18n.__)('An error occurred while renaming the template part.');
        const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : fallbackErrorMessage;
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    }
    return (0, _react.createElement)("form", {
      onSubmit: onTemplateRename
    }, (0, _react.createElement)(_components.__experimentalVStack, {
      spacing: "5"
    }, (0, _react.createElement)(_components.TextControl, {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      label: (0, _i18n.__)('Name'),
      value: editedTitle,
      onChange: setEditedTitle,
      required: true
    }), (0, _react.createElement)(_components.__experimentalHStack, {
      justify: "right"
    }, (0, _react.createElement)(_components.Button, {
      variant: "tertiary",
      onClick: closeModal,
      __next40pxDefaultSize: true
    }, (0, _i18n.__)('Cancel')), (0, _react.createElement)(_components.Button, {
      variant: "primary",
      type: "submit",
      __next40pxDefaultSize: true
    }, (0, _i18n.__)('Save')))));
  }
};
function usePostActions(postType, onActionPerformed) {
  const {
    postTypeObject
  } = (0, _data.useSelect)(select => {
    const {
      getPostType
    } = select(_coreData.store);
    return {
      postTypeObject: getPostType(postType)
    };
  }, [postType]);
  const permanentlyDeletePostAction = usePermanentlyDeletePostAction();
  const restorePostAction = useRestorePostAction();
  const isTemplateOrTemplatePart = [_constants.TEMPLATE_POST_TYPE, _constants.TEMPLATE_PART_POST_TYPE].includes(postType);
  const isPattern = postType === _constants.PATTERN_POST_TYPE;
  const isLoaded = !!postTypeObject;
  return (0, _element.useMemo)(() => {
    if (!isLoaded) {
      return [];
    }
    const actions = [isTemplateOrTemplatePart && resetTemplateAction, postTypeObject?.viewable && viewPostAction, !isTemplateOrTemplatePart && restorePostAction, isTemplateOrTemplatePart && deleteTemplateAction, !isTemplateOrTemplatePart && permanentlyDeletePostAction, postRevisionsAction, process.env.IS_GUTENBERG_PLUGIN ? !isTemplateOrTemplatePart && !isPattern && duplicatePostAction : false, !isTemplateOrTemplatePart && renamePostAction, isTemplateOrTemplatePart && renameTemplateAction, !isTemplateOrTemplatePart && trashPostAction].filter(Boolean);
    if (onActionPerformed) {
      for (let i = 0; i < actions.length; ++i) {
        if (actions[i].callback) {
          const existingCallback = actions[i].callback;
          actions[i] = {
            ...actions[i],
            callback: (items, _onActionPerformed) => {
              existingCallback(items, _items => {
                if (_onActionPerformed) {
                  _onActionPerformed(_items);
                }
                onActionPerformed(actions[i].id, _items);
              });
            }
          };
        }
        if (actions[i].RenderModal) {
          const ExistingRenderModal = actions[i].RenderModal;
          actions[i] = {
            ...actions[i],
            RenderModal: props => {
              return (0, _react.createElement)(ExistingRenderModal, {
                ...props,
                onActionPerformed: _items => {
                  if (props.onActionPerformed) {
                    props.onActionPerformed(_items);
                  }
                  onActionPerformed(actions[i].id, _items);
                }
              });
            }
          };
        }
      }
    }
    return actions;
  }, [isTemplateOrTemplatePart, isPattern, postTypeObject?.viewable, permanentlyDeletePostAction, restorePostAction, onActionPerformed, isLoaded]);
}
//# sourceMappingURL=actions.js.map