"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditorProvider = EditorProvider;
exports.default = exports.ExperimentalEditorProvider = void 0;
var _react = require("react");
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _i18n = require("@wordpress/i18n");
var _coreData = require("@wordpress/core-data");
var _blockEditor = require("@wordpress/block-editor");
var _notices = require("@wordpress/notices");
var _patterns = require("@wordpress/patterns");
var _blocks = require("@wordpress/blocks");
var _withRegistryProvider = _interopRequireDefault(require("./with-registry-provider"));
var _store = require("../../store");
var _useBlockEditorSettings = _interopRequireDefault(require("./use-block-editor-settings"));
var _lockUnlock = require("../../lock-unlock");
var _disableNonPageContentBlocks = _interopRequireDefault(require("./disable-non-page-content-blocks"));
var _navigationBlockEditingMode = _interopRequireDefault(require("./navigation-block-editing-mode"));
var _useHideBlocksFromInserter = require("./use-hide-blocks-from-inserter");
var _commands = _interopRequireDefault(require("../commands"));
var _blockRemovalWarnings = _interopRequireDefault(require("../block-removal-warnings"));
var _startPageOptions = _interopRequireDefault(require("../start-page-options"));
var _keyboardShortcutHelpModal = _interopRequireDefault(require("../keyboard-shortcut-help-modal"));
var _contentOnlySettingsMenu = _interopRequireDefault(require("../block-settings-menu/content-only-settings-menu"));
var _startTemplateOptions = _interopRequireDefault(require("../start-template-options"));
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  ExperimentalBlockEditorProvider
} = (0, _lockUnlock.unlock)(_blockEditor.privateApis);
const {
  PatternsMenuItems
} = (0, _lockUnlock.unlock)(_patterns.privateApis);
const noop = () => {};

/**
 * These are global entities that are only there to split blocks into logical units
 * They don't provide a "context" for the current post/page being rendered.
 * So we should not use their ids as post context. This is important to allow post blocks
 * (post content, post title) to be used within them without issues.
 */
const NON_CONTEXTUAL_POST_TYPES = ['wp_block', 'wp_template', 'wp_navigation', 'wp_template_part'];

/**
 * Depending on the post, template and template mode,
 * returns the appropriate blocks and change handlers for the block editor provider.
 *
 * @param {Array}   post     Block list.
 * @param {boolean} template Whether the page content has focus (and the surrounding template is inert). If `true` return page content blocks. Default `false`.
 * @param {string}  mode     Rendering mode.
 * @return {Array} Block editor props.
 */
function useBlockEditorProps(post, template, mode) {
  const rootLevelPost = mode === 'post-only' || !template ? 'post' : 'template';
  const [postBlocks, onInput, onChange] = (0, _coreData.useEntityBlockEditor)('postType', post.type, {
    id: post.id
  });
  const [templateBlocks, onInputTemplate, onChangeTemplate] = (0, _coreData.useEntityBlockEditor)('postType', template?.type, {
    id: template?.id
  });
  const maybeNavigationBlocks = (0, _element.useMemo)(() => {
    if (post.type === 'wp_navigation') {
      return [(0, _blocks.createBlock)('core/navigation', {
        ref: post.id,
        // As the parent editor is locked with `templateLock`, the template locking
        // must be explicitly "unset" on the block itself to allow the user to modify
        // the block's content.
        templateLock: false
      })];
    }
  }, [post.type, post.id]);

  // It is important that we don't create a new instance of blocks on every change
  // We should only create a new instance if the blocks them selves change, not a dependency of them.
  const blocks = (0, _element.useMemo)(() => {
    if (maybeNavigationBlocks) {
      return maybeNavigationBlocks;
    }
    if (rootLevelPost === 'template') {
      return templateBlocks;
    }
    return postBlocks;
  }, [maybeNavigationBlocks, rootLevelPost, templateBlocks, postBlocks]);

  // Handle fallback to postBlocks outside of the above useMemo, to ensure
  // that constructed block templates that call `createBlock` are not generated
  // too frequently. This ensures that clientIds are stable.
  const disableRootLevelChanges = !!template && mode === 'template-locked' || post.type === 'wp_navigation';
  if (disableRootLevelChanges) {
    return [blocks, noop, noop];
  }
  return [blocks, rootLevelPost === 'post' ? onInput : onInputTemplate, rootLevelPost === 'post' ? onChange : onChangeTemplate];
}
const ExperimentalEditorProvider = exports.ExperimentalEditorProvider = (0, _withRegistryProvider.default)(({
  post,
  settings,
  recovery,
  initialEdits,
  children,
  BlockEditorProviderComponent = ExperimentalBlockEditorProvider,
  __unstableTemplate: template
}) => {
  const mode = (0, _data.useSelect)(select => select(_store.store).getRenderingMode(), []);
  const shouldRenderTemplate = !!template && mode !== 'post-only';
  const rootLevelPost = shouldRenderTemplate ? template : post;
  const defaultBlockContext = (0, _element.useMemo)(() => {
    const postContext = !NON_CONTEXTUAL_POST_TYPES.includes(rootLevelPost.type) || shouldRenderTemplate ? {
      postId: post.id,
      postType: post.type
    } : {};
    return {
      ...postContext,
      templateSlug: rootLevelPost.type === 'wp_template' ? rootLevelPost.slug : undefined
    };
  }, [shouldRenderTemplate, post.id, post.type, rootLevelPost.type, rootLevelPost.slug]);
  const {
    editorSettings,
    selection,
    isReady
  } = (0, _data.useSelect)(select => {
    const {
      getEditorSettings,
      getEditorSelection,
      __unstableIsEditorReady
    } = select(_store.store);
    return {
      editorSettings: getEditorSettings(),
      isReady: __unstableIsEditorReady(),
      selection: getEditorSelection()
    };
  }, []);
  const {
    id,
    type
  } = rootLevelPost;
  const blockEditorSettings = (0, _useBlockEditorSettings.default)(editorSettings, type, id, mode);
  const [blocks, onInput, onChange] = useBlockEditorProps(post, template, mode);
  const {
    updatePostLock,
    setupEditor,
    updateEditorSettings,
    setCurrentTemplateId,
    setEditedPost,
    setRenderingMode
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  const {
    createWarningNotice
  } = (0, _data.useDispatch)(_notices.store);

  // Ideally this should be synced on each change and not just something you do once.
  (0, _element.useLayoutEffect)(() => {
    // Assume that we don't need to initialize in the case of an error recovery.
    if (recovery) {
      return;
    }
    updatePostLock(settings.postLock);
    setupEditor(post, initialEdits, settings.template);
    if (settings.autosave) {
      createWarningNotice((0, _i18n.__)('There is an autosave of this post that is more recent than the version below.'), {
        id: 'autosave-exists',
        actions: [{
          label: (0, _i18n.__)('View the autosave'),
          url: settings.autosave.editLink
        }]
      });
    }
  }, []);

  // Synchronizes the active post with the state
  (0, _element.useEffect)(() => {
    setEditedPost(post.type, post.id);
  }, [post.type, post.id, setEditedPost]);

  // Synchronize the editor settings as they change.
  (0, _element.useEffect)(() => {
    updateEditorSettings(settings);
  }, [settings, updateEditorSettings]);

  // Synchronizes the active template with the state.
  (0, _element.useEffect)(() => {
    setCurrentTemplateId(template?.id);
  }, [template?.id, setCurrentTemplateId]);

  // Sets the right rendering mode when loading the editor.
  (0, _element.useEffect)(() => {
    var _settings$defaultRend;
    setRenderingMode((_settings$defaultRend = settings.defaultRenderingMode) !== null && _settings$defaultRend !== void 0 ? _settings$defaultRend : 'post-only');
  }, [settings.defaultRenderingMode, setRenderingMode]);
  (0, _useHideBlocksFromInserter.useHideBlocksFromInserter)(post.type, mode);

  // Register the editor commands.
  (0, _commands.default)();
  if (!isReady) {
    return null;
  }
  return (0, _react.createElement)(_coreData.EntityProvider, {
    kind: "root",
    type: "site"
  }, (0, _react.createElement)(_coreData.EntityProvider, {
    kind: "postType",
    type: post.type,
    id: post.id
  }, (0, _react.createElement)(_blockEditor.BlockContextProvider, {
    value: defaultBlockContext
  }, (0, _react.createElement)(BlockEditorProviderComponent, {
    value: blocks,
    onChange: onChange,
    onInput: onInput,
    selection: selection,
    settings: blockEditorSettings,
    useSubRegistry: false
  }, children, !settings.__unstableIsPreviewMode && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(PatternsMenuItems, null), (0, _react.createElement)(_contentOnlySettingsMenu.default, null), mode === 'template-locked' && (0, _react.createElement)(_disableNonPageContentBlocks.default, null), type === 'wp_navigation' && (0, _react.createElement)(_navigationBlockEditingMode.default, null), (0, _react.createElement)(_keyboardShortcutHelpModal.default, null), (0, _react.createElement)(_blockRemovalWarnings.default, null), (0, _react.createElement)(_startPageOptions.default, null), (0, _react.createElement)(_startTemplateOptions.default, null))))));
});
function EditorProvider(props) {
  return (0, _react.createElement)(ExperimentalEditorProvider, {
    ...props,
    BlockEditorProviderComponent: _blockEditor.BlockEditorProvider
  }, props.children);
}
var _default = exports.default = EditorProvider;
//# sourceMappingURL=index.js.map