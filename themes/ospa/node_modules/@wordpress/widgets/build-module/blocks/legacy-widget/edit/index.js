import { createElement, Fragment } from "react";
/**
 * External dependencies
 */
import clsx from 'clsx';

/**
 * WordPress dependencies
 */
import { useBlockProps, BlockControls, InspectorControls, BlockIcon, store as blockEditorStore } from '@wordpress/block-editor';
import { Flex, FlexBlock, Spinner, Placeholder } from '@wordpress/components';
import { brush as brushIcon } from '@wordpress/icons';
import { __ } from '@wordpress/i18n';
import { useState, useCallback } from '@wordpress/element';
import { useSelect } from '@wordpress/data';
import { useEntityRecord } from '@wordpress/core-data';

/**
 * Internal dependencies
 */
import WidgetTypeSelector from './widget-type-selector';
import InspectorCard from './inspector-card';
import Form from './form';
import Preview from './preview';
import NoPreview from './no-preview';
import ConvertToBlocksButton from './convert-to-blocks-button';
export default function Edit(props) {
  const {
    id,
    idBase
  } = props.attributes;
  const {
    isWide = false
  } = props;
  const blockProps = useBlockProps({
    className: clsx({
      'is-wide-widget': isWide
    })
  });
  return createElement("div", {
    ...blockProps
  }, !id && !idBase ? createElement(Empty, {
    ...props
  }) : createElement(NotEmpty, {
    ...props
  }));
}
function Empty({
  attributes: {
    id,
    idBase
  },
  setAttributes
}) {
  return createElement(Placeholder, {
    icon: createElement(BlockIcon, {
      icon: brushIcon
    }),
    label: __('Legacy Widget')
  }, createElement(Flex, null, createElement(FlexBlock, null, createElement(WidgetTypeSelector, {
    selectedId: id !== null && id !== void 0 ? id : idBase,
    onSelect: ({
      selectedId,
      isMulti
    }) => {
      if (!selectedId) {
        setAttributes({
          id: null,
          idBase: null,
          instance: null
        });
      } else if (isMulti) {
        setAttributes({
          id: null,
          idBase: selectedId,
          instance: {}
        });
      } else {
        setAttributes({
          id: selectedId,
          idBase: null,
          instance: null
        });
      }
    }
  }))));
}
function NotEmpty({
  attributes: {
    id,
    idBase,
    instance
  },
  setAttributes,
  clientId,
  isSelected,
  isWide = false
}) {
  const [hasPreview, setHasPreview] = useState(null);
  const widgetTypeId = id !== null && id !== void 0 ? id : idBase;
  const {
    record: widgetType,
    hasResolved: hasResolvedWidgetType
  } = useEntityRecord('root', 'widgetType', widgetTypeId);
  const isNavigationMode = useSelect(select => select(blockEditorStore).isNavigationMode(), []);
  const setInstance = useCallback(nextInstance => {
    setAttributes({
      instance: nextInstance
    });
  }, []);
  if (!widgetType && hasResolvedWidgetType) {
    return createElement(Placeholder, {
      icon: createElement(BlockIcon, {
        icon: brushIcon
      }),
      label: __('Legacy Widget')
    }, __('Widget is missing.'));
  }
  if (!hasResolvedWidgetType) {
    return createElement(Placeholder, null, createElement(Spinner, null));
  }
  const mode = idBase && (isNavigationMode || !isSelected) ? 'preview' : 'edit';
  return createElement(Fragment, null, idBase === 'text' && createElement(BlockControls, {
    group: "other"
  }, createElement(ConvertToBlocksButton, {
    clientId: clientId,
    rawInstance: instance.raw
  })), createElement(InspectorControls, null, createElement(InspectorCard, {
    name: widgetType.name,
    description: widgetType.description
  })), createElement(Form, {
    title: widgetType.name,
    isVisible: mode === 'edit',
    id: id,
    idBase: idBase,
    instance: instance,
    isWide: isWide,
    onChangeInstance: setInstance,
    onChangeHasPreview: setHasPreview
  }), idBase && createElement(Fragment, null, hasPreview === null && mode === 'preview' && createElement(Placeholder, null, createElement(Spinner, null)), hasPreview === true && createElement(Preview, {
    idBase: idBase,
    instance: instance,
    isVisible: mode === 'preview'
  }), hasPreview === false && mode === 'preview' && createElement(NoPreview, {
    name: widgetType.name
  })));
}
//# sourceMappingURL=index.js.map