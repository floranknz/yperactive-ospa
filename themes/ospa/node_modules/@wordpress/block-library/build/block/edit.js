"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ReusableBlockEditRecursionWrapper;
var _react = require("react");
var _clsx = _interopRequireDefault(require("clsx"));
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _coreData = require("@wordpress/core-data");
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _blockEditor = require("@wordpress/block-editor");
var _patterns = require("@wordpress/patterns");
var _blocks = require("@wordpress/blocks");
var _index = require("./index");
var _lockUnlock = require("../lock-unlock");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  useLayoutClasses
} = (0, _lockUnlock.unlock)(_blockEditor.privateApis);
const {
  isOverridableBlock
} = (0, _lockUnlock.unlock)(_patterns.privateApis);
const fullAlignments = ['full', 'wide', 'left', 'right'];
const useInferredLayout = (blocks, parentLayout) => {
  const initialInferredAlignmentRef = (0, _element.useRef)();
  return (0, _element.useMemo)(() => {
    // Exit early if the pattern's blocks haven't loaded yet.
    if (!blocks?.length) {
      return {};
    }
    let alignment = initialInferredAlignmentRef.current;

    // Only track the initial alignment so that temporarily removed
    // alignments can be reapplied.
    if (alignment === undefined) {
      const isConstrained = parentLayout?.type === 'constrained';
      const hasFullAlignment = blocks.some(block => fullAlignments.includes(block.attributes.align));
      alignment = isConstrained && hasFullAlignment ? 'full' : null;
      initialInferredAlignmentRef.current = alignment;
    }
    const layout = alignment ? parentLayout : undefined;
    return {
      alignment,
      layout
    };
  }, [blocks, parentLayout]);
};
function hasOverridableBlocks(blocks) {
  return blocks.some(block => {
    if (isOverridableBlock(block)) {
      return true;
    }
    return hasOverridableBlocks(block.innerBlocks);
  });
}
function setBlockEditMode(setEditMode, blocks, mode) {
  blocks.forEach(block => {
    const editMode = mode || (isOverridableBlock(block) ? 'contentOnly' : 'disabled');
    setEditMode(block.clientId, editMode);
    setBlockEditMode(setEditMode, block.innerBlocks,
    // Disable editing for nested patterns.
    block.name === _index.name ? 'disabled' : mode);
  });
}
function RecursionWarning() {
  const blockProps = (0, _blockEditor.useBlockProps)();
  return (0, _react.createElement)("div", {
    ...blockProps
  }, (0, _react.createElement)(_blockEditor.Warning, null, (0, _i18n.__)('Block cannot be rendered inside itself.')));
}
const NOOP = () => {};

// Wrap the main Edit function for the pattern block with a recursion wrapper
// that allows short-circuiting rendering as early as possible, before any
// of the other effects in the block edit have run.
function ReusableBlockEditRecursionWrapper(props) {
  const {
    ref
  } = props.attributes;
  const hasAlreadyRendered = (0, _blockEditor.useHasRecursion)(ref);
  if (hasAlreadyRendered) {
    return (0, _react.createElement)(RecursionWarning, null);
  }
  return (0, _react.createElement)(_blockEditor.RecursionProvider, {
    uniqueId: ref
  }, (0, _react.createElement)(ReusableBlockEdit, {
    ...props
  }));
}
function ReusableBlockEdit({
  name,
  attributes: {
    ref,
    content
  },
  __unstableParentLayout: parentLayout,
  clientId: patternClientId,
  setAttributes
}) {
  const {
    record,
    hasResolved
  } = (0, _coreData.useEntityRecord)('postType', 'wp_block', ref);
  const [blocks] = (0, _coreData.useEntityBlockEditor)('postType', 'wp_block', {
    id: ref
  });
  const isMissing = hasResolved && !record;
  const {
    setBlockEditingMode,
    __unstableMarkLastChangeAsPersistent
  } = (0, _data.useDispatch)(_blockEditor.store);
  const {
    innerBlocks,
    userCanEdit,
    onNavigateToEntityRecord,
    editingMode,
    hasPatternOverridesSource
  } = (0, _data.useSelect)(select => {
    const {
      canUser
    } = select(_coreData.store);
    const {
      getBlocks,
      getSettings,
      getBlockEditingMode: _getBlockEditingMode
    } = select(_blockEditor.store);
    const {
      getBlockBindingsSource
    } = (0, _lockUnlock.unlock)(select(_blocks.store));
    const canEdit = canUser('update', 'blocks', ref);

    // For editing link to the site editor if the theme and user permissions support it.
    return {
      innerBlocks: getBlocks(patternClientId),
      userCanEdit: canEdit,
      getBlockEditingMode: _getBlockEditingMode,
      onNavigateToEntityRecord: getSettings().onNavigateToEntityRecord,
      editingMode: _getBlockEditingMode(patternClientId),
      hasPatternOverridesSource: !!getBlockBindingsSource('core/pattern-overrides')
    };
  }, [patternClientId, ref]);

  // Sync the editing mode of the pattern block with the inner blocks.
  (0, _element.useEffect)(() => {
    setBlockEditMode(setBlockEditingMode, innerBlocks,
    // Disable editing if the pattern itself is disabled.
    editingMode === 'disabled' || !hasPatternOverridesSource ? 'disabled' : undefined);
  }, [editingMode, innerBlocks, setBlockEditingMode, hasPatternOverridesSource]);
  const canOverrideBlocks = (0, _element.useMemo)(() => hasPatternOverridesSource && hasOverridableBlocks(blocks), [hasPatternOverridesSource, blocks]);
  const {
    alignment,
    layout
  } = useInferredLayout(blocks, parentLayout);
  const layoutClasses = useLayoutClasses({
    layout
  }, name);
  const blockProps = (0, _blockEditor.useBlockProps)({
    className: (0, _clsx.default)('block-library-block__reusable-block-container', layout && layoutClasses, {
      [`align${alignment}`]: alignment
    })
  });

  // Use `blocks` variable until `innerBlocks` is populated, which has the proper clientIds.
  const innerBlocksProps = (0, _blockEditor.useInnerBlocksProps)(blockProps, {
    templateLock: 'all',
    layout,
    value: innerBlocks.length > 0 ? innerBlocks : blocks,
    onInput: NOOP,
    onChange: NOOP,
    renderAppender: blocks?.length ? undefined : blocks.ButtonBlockAppender
  });
  const handleEditOriginal = () => {
    onNavigateToEntityRecord({
      postId: ref,
      postType: 'wp_block'
    });
  };
  const resetContent = () => {
    if (content) {
      // Make sure any previous changes are persisted before resetting.
      __unstableMarkLastChangeAsPersistent();
      setAttributes({
        content: undefined
      });
    }
  };
  let children = null;
  if (isMissing) {
    children = (0, _react.createElement)(_blockEditor.Warning, null, (0, _i18n.__)('Block has been deleted or is unavailable.'));
  }
  if (!hasResolved) {
    children = (0, _react.createElement)(_components.Placeholder, null, (0, _react.createElement)(_components.Spinner, null));
  }
  return (0, _react.createElement)(_react.Fragment, null, userCanEdit && onNavigateToEntityRecord && (0, _react.createElement)(_blockEditor.BlockControls, null, (0, _react.createElement)(_components.ToolbarGroup, null, (0, _react.createElement)(_components.ToolbarButton, {
    onClick: handleEditOriginal
  }, (0, _i18n.__)('Edit original')))), canOverrideBlocks && (0, _react.createElement)(_blockEditor.BlockControls, null, (0, _react.createElement)(_components.ToolbarGroup, null, (0, _react.createElement)(_components.ToolbarButton, {
    onClick: resetContent,
    disabled: !content,
    __experimentalIsFocusable: true
  }, (0, _i18n.__)('Reset')))), children === null ? (0, _react.createElement)("div", {
    ...innerBlocksProps
  }) : (0, _react.createElement)("div", {
    ...blockProps
  }, children));
}
//# sourceMappingURL=edit.js.map